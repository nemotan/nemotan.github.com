---
layout: post
title: jvm【一】java8中基本数据类型以及自动转换
categories:
- jvm
tags:
- jvm
---
##java8中基本数据类型以及所占字节
<table style="width:98%" border="2">
	<tr>
		<td>类型</td>
		<td>占用存储空间（字节，1字节=8位）</td>
		<td>范围</td>
	</tr>
	<tr>
		<td>boolean</td>
		<td>1/8字节</td>
		<td></td>
	</tr>
	<tr>
		<td>char</td>
		<td>2个字节</td>
		<td>java字符采用Unicode编码，每个字符占2个字节</td>
	</tr>
	<tr>
		<td>byte</td>
		<td>1字节</td>
		<td>-128到127之间的任意整数 </td>
	</tr>
	<tr>
		<td>short</td>
		<td>2字节</td>
		<td>-2^15-2^15-1之间的任意整数 </td>
	</tr>
	<tr>
		<td>int</td>
		<td>4字节</td>
		<td>-2^31到2^31-1之间的任意整数</td>
	</tr>
	<tr>
		<td>float</td>
		<td>4字节</td>
		<td>根据IEEE754-1985标准 </td>
	</tr>
	<tr>
		<td>long</td>
		<td>8字节</td>
		<td>-2^63到2^63-1之间的任意整数</td>
	</tr>
	<tr>
		<td>double</td>
		<td>8字节</td>
		<td>根据IEEE754-1985标准</td>
	</tr>
</table>

##java数据类型转换
数据类型的转换分为**自动转换**和**强制转换**自动转换是程序在执行过程中“悄然”进行的转换，不需要用户提前声明，一般是从位数低的类型向位数高的类型转换；强制类型转换则必须在代码中声明，转换顺序不受限制。
###自动转换
实例一：
	
	byte b;
	b=3;
	b=(byte)b*3  //编译出错，因为(byte)的运算级别比*高,所以会先转换b后再*3
	b=(byte)(b*3)  //正确
实例二：
	 
	byte b = 50;
	char c = 'a';
	short s = 1024;
	int i = 50000
	float f =5.67f
	double d =0.1234
	double result = (f * b) + (i / c) - (d * s);
	#解释
	第一个表达式f * b中，b被提升为float类型,该子表达式的结果也提升为float类型。
    第二个表达式i / c中，变量c被提升为int类型，该子表达式的结果提升为int类型。
    第三个表达式d * s中，变量s被提升为double类型，该子表达式的结果提升为double型。
    最后，这三个结果类型分别是float，int和double类型，想减后该表达式的最后的结果就是double类型。
            
实例三：
	
	(1)short s1 = 1; s1 = s1 + 1;和(2) short s1 = 1; s1 += 1两个结果如何？ 
  	结果（1）编译出错，(2)没问题

在s1=s1+1;中，s1+1
运算的结果是int型，把它赋值给一个 short型变量s1，所以会报错；而在s1+=1;中，由于
是s1是short类型的，所以1首先被强制转换为short型，然后再参与运算，并且结果也是
short类型的，因此不会报错。那么，s1=1+1;为什么不报错呢？这是因为1+1是个编译时可
以确定的常量，“+”运算在编译时就被执行了，而不是在程序执行的时候，这个语句的效果
等同于s1=2，所以不会报错。前面讲过了，对基本类型执行强制类型转换可能得出错误的
结果，因此在使用+=、 -=、*=、/=、%=等运算符时，要多加注意。

**注意：**
当使用+=、-=、*=、/=、%=、运算符对基本类型进行运算时，遵循如下规则：
• 运算符右边的数值将首先被强制转换成与运算符左边数值相同的类型，然后再执行运算，
且运算结果与运算符左边数值类型相同。
###强制转换
针对实例三种的（1）表达式，如果改成short s1 = 1; s1 = (short)(s1 + 1);就不会有问题，这就是强转了，强转会失去精度。